---
title: "Changing CpG sites"
format: 
  html:
    link-external-newwindow: true
    fig-cap-location: bottom
    fig-width: 200
    fig-height: 200
---

**Identifying CpG sites that change over the lekking season** 

Next, we want to identify CpG sites that significantly change in methylation level over the lekking season. To do so, we build a generalized linear mixed effect model per CpG site, using the time period (pre- or post-lekking) as a fixed effect. Moreover, as there are multiple samples for each individual, we correct for the non-independence of samples by including ID as a random effect. The response variables in these models are both the number of methylated and number of unmethylated C's, using the `cbind` function.

## Prepare the data {#sec-change}

```{r model, echo=T, eval=F}
### load packages 
pacman::p_load(tidyverse, data.table, tibble, performance, matrixStats, 
               parallel, performance, lmerTest, tidystats, insight, rptR)

### load epi data
load(file = "data/processed/methylkit_prepost_long_onlyvar_thres0.3_min_0.5_group.RData") 

### load phenotype data 
load("data/phenotypes/fulldata_complete_epi_withdates.RData")
prepost <- subset(all_pheno_epi, !is.na(prepost)) #phenotype dataset also consists of other individuals not part of this study
rm(all_pheno_epi)

### merge with metadata

prepost_long <- left_join(prepost_long, prepost[,c("id", "prepost", "Core", "year", "born","site", "fulldate")], 
                          by = c("id", "year", "fulldate"))

prepost_long <- prepost_long %>% mutate(age_year = as.factor(case_when(Core == "Core" ~ year - born,
                                                        Core == "No core" ~ NA)),
                                        age = as.factor(case_when(Core == "Core" & (year - born > 1) ~ "Adult",
                                                        Core == "Core" & (year - born == 1) ~ "Yearling",
                                                        Core == "No core" ~ "Adult")))

### convert data to a list, one per CpG site
data <- prepost_long %>% group_split(chr_pos)

```

## Function to run the model

Below you will find the full model used to 1) run the model in parallel per CpG site and 2) collect the output in a dataframe. Most importantly, this is the formula run for the model:

```         
lme4::glmer(cbind(numC, numT) ~ prepost + (1|id), family = "binomial")
```

```{r function, eval=F}
#| code-fold: true
### define function to collect overdispersion statistics
overdisp.lmer_fun <- function(model) {
  vpars <- function(m) {
    nrow(m)*(nrow(m)+1)/2
  }
  model.df <- sum(sapply(VarCorr(model),vpars))+length(fixef(model))
  rdf <- nrow(model.frame(model))-model.df
  rp <- residuals(model,type="pearson")
  Pearson.chisq <- sum(rp^2)
  prat <- Pearson.chisq/rdf
  pval <- pchisq(Pearson.chisq, df=rdf, lower.tail=FALSE)
  data.frame(chisq=Pearson.chisq,ratio=prat,rdf=rdf,p=pval)
}

### build function to run the model
function_model_glmer <- function(df){tryCatch({
  chr_pos <- as.character(df[1,1])
  df <- as.data.frame(df)
  df$prepost <- as.factor(df$prepost)
  df$id <- as.factor(df$id)
  
  # model
  model <- lme4::glmer(cbind(numC, numT) ~ prepost + (1|id), family = "binomial", df)
  
  #fixed effects
  prepost_estimate <- summary(model)$coefficients[2,1]
  prepost_se <- summary(model)$coefficients[2,2]
  prepost_zval <- summary(model)$coefficients[2,3]
  prepost_pval <-  summary(model)$coefficients[2,4]
  
  #random effects 
  id_sd <- attributes(VarCorr(model)$id)$stddev
  id_variance <- data.frame(VarCorr(model), comp="Variance")[1,4]
  
  rsqc <- performance::r2(model)$R2_conditional #fixed plus random effects relative to overall variance
  rsqm <- performance::r2(model)$R2_marginal #fixed effects relative to overall variance
  
  dispersion.chisq <- overdisp.lmer_fun(model)[1,1]
  dispersion.ratio <- overdisp.lmer_fun(model)[1,2]
  dispersion.rdf <- overdisp.lmer_fun(model)[1,3]
  dispersion.pval <- overdisp.lmer_fun(model)[1,4]
  
  isSingular <- isSingular(model)

  if(is.null(summary(model)$optinfo$conv$lme4$messages )){
    convergence <- NA
  }

  if(!is.null(summary(model)$optinfo$conv$lme4$messages )){
    convergence <- summary(model)$optinfo$conv$lme4$messages
  }
  
  icc_id <- icc(model, by_group = TRUE, tolerance = 0)[1,2]
  
  return(data.frame(chr_pos=chr_pos, 
                    prepost_estimate = prepost_estimate,
                    prepost_se = prepost_se,
                    prepost_zval = prepost_zval,
                    prepost_pval = prepost_pval,
                    id_sd = id_sd,
                    id_variance = id_variance,
                    rsqc = rsqc,
                    rsqm = rsqm,
                    dispersion.chisq = dispersion.chisq,
                    dispersion.ratio = dispersion.ratio,
                    dispersion.rdf = dispersion.rdf,
                    dispersion.pval = dispersion.pval,
                    isSingular = isSingular,
                    convergence = convergence,
                    icc_id = icc_id
                    ))
}, error = function(e){cat("ERROR :", conditionMessage(e), "\n");print(chr_pos)})
}
```

## Run the model {#sec-changingcpg}

Here, we run the model in parallel, and next exclude CpG sites where there was overdispersion or convergence errors. After this filter step, we apply an FDR multiple-testing correction.

```{r run_model, echo=T, eval=F}

### run the model in parallel per CpG site (list item)
out_glmer <- parallel::mclapply(data, function_model_glmer, mc.cores=4)
out_glmer <- do.call(rbind.data.frame, out_glmer)
```

## Explore and filter for under- and overdispersion

We can plot a histogram of the dispersion ratio and make a QQ plot to identify whether there is under/overdispersion and how to best filter for it.

![Histogram dispersion ratio](../plots/model_out/changing_histogram_dispersion_glmer_raw.png) ![QQ plot model changing CpG sites](../plots/model_out/changing_qqplot_glmer.png)

Next, we explore how to best filter for overdispersion: using a dispersion ratio threshold of 1.1 or by filtering for the percentile.

```{r explore_dispersion, echo=T, eval=F}
out_glmer_threshold <- subset(out_glmer_raw, dispersion.ratio < 1.1 & dispersion.pval > 0.05 & is.na(convergence)) # 168720, 179311 with cov not nT
out_glmer_threshold$prepost_qval <- p.adjust(out_glmer_threshold$prepost_pval, method = "fdr", n = nrow(out_glmer_threshold))

nrow(out_glmer_threshold)/nrow(out_glmer_raw) # = 0.53
nrow(subset(out_glmer_threshold, prepost_qval < 0.05)) # N = 3563

## second option: within the 90% quantiles (not 95% because too much overdispersion)
out_glmer_perc <- subset(out_glmer_raw, dispersion.ratio < as.vector(quantile(out_glmer_raw$dispersion.ratio, 0.95)) & dispersion.ratio > as.vector(quantile(out_glmer_raw$dispersion.ratio, 0.05)))
out_glmer_perc$prepost_qval <- p.adjust(out_glmer_perc$prepost_pval, method = "fdr", n = nrow(out_glmer_perc))
nrow(out_glmer_perc)/nrow(out_glmer_raw) # = 0.90 (obvs but as sanity check)
nrow(subset(out_glmer_perc, prepost_qval < 0.05)) # N = 19110


```

This is what the qqplot looks like (plotting the FDR-corrected q-values, not p-values).

![QQ-plot when filtering for ratio \< 1.1](../plots/model_out/qqplot_changing_qqplot_glmer_threshold.png) ![QQ-plot when filtering for 90% percentile of the ratio](../plots/model_out/qqplot_changing_qqplot_glmer_90percentile.png)

Since there is still alot of overdispersion when filtering for the 90% quantile of the dispersion ratio, let's filter for the ratio instead (absolute cut-off at \< 1.1 and p-value \> 0.05)

## Filter for average methylation % differences

A "changing CpG site" is then defined as a CpG site with a significant effect of time period (FDR-corrected q-value \< 0.05) and mean delta methylation % (across individuals) of at least -10% or 10%.

```{r subset, echo=T, eval = F}

#### Filter for mean delta methylation ####

load(file = "results/modeloutput/all_sites_deltameth.RData") # this file contains per CpG site the delta methylation levels

### Calculate average delta_meth per CpG site

mean_delta_meth <- delta_meth %>% group_by(chr_pos) %>% summarise_at(vars(delta_meth), funs(mean(., na.rm=TRUE)))
names(mean_delta_meth)[2] <- "mean_delta_meth"

out_glmer <- left_join(out_glmer_threshold, mean_delta_meth, by = "chr_pos")

### Filter min absolute mean methylation of 10%

## save the epi data only from cpg's that are sig
sub_glmer_prepost <- subset(out_glmer, prepost_qval < 0.05 & abs(mean_delta_meth) >= 0.1)

changing_cpg <- subset(prepost_long, chr_pos %in% sub_glmer_prepost$chr_pos)
save(changing_cpg, file="results/modeloutput/subset_sites_sig_prepost.RData")

```

A total of 434 CpG sites significantly change across the lekking period.

## Plotting

### Volcano plot

Next, we make a volcano plot to see the results.

```{r volcano, echo=T, eval= F}
out_glmer <- out_glmer %>% 
  mutate(sig = as.factor(case_when(abs(mean_delta_meth) >= 0.1 & prepost_qval < 0.05 ~ "sig", TRUE ~ "nonsig")))

clrs <- viridisLite::viridis(6)
ggplot(out_glmer, aes(x = mean_delta_meth, y = -log10(as.numeric(prepost_qval)))) + 
    geom_point(size=4, alpha=0.5, aes(col = as.factor(sig))) +
    labs(x = expression("Mean "*Delta*" methylation %"), y = "-log10(q-value)") +
    scale_color_manual(values=c("grey60", clrs[4])) +
    geom_hline(yintercept = -log10(0.05), col = "darkred", linetype = "dotted", linewidth = 1) +
    geom_vline(xintercept = -0.1, col = "darkred", linetype = "dotted", linewidth = 1) +
    geom_vline(xintercept = 0.1, col = "darkred", linetype = "dotted", linewidth = 1) +
    theme(legend.position="none") -> volcano_change

```

![Volcano plot changing CpG sites](../plots/model_out/volcano_change.png){width="450" fig-align="left"}

Interestingly, there seems to more CpG sites that increase in methylation over time compared to CpG sites that increase in methylation over time.

### Raw data

To assess whether the models performed well, I also plotted the raw data of the five most significantly changing CpG sites.

```{r raw plots, echo=T, eval=F}
# raw plot for the 1st significant CpG site, repeat for the other 4 and combine with cowplot

out_glmer <- out_glmer %>% arrange(prepost_qval)

subset(changing_cpg, chr_pos == out_glmer$chr_pos[1]) %>%
  arrange(id, year) %>%
  ggplot(., aes(x = prepost, y = methperc))+
  geom_boxplot(linewidth=1, outlier.shape=NA) + 
  geom_path(aes(group = id_year), alpha = 0.8, col = "grey60", position = position_jitter(width = 0.1, seed = 3922)) +
  geom_point(aes(alpha = 0.8, size=cov), col = clrs[4], position = position_jitter(width = 0.1, seed = 3922)) + 
  labs(x = "Time period", y = "Methylation percentage", subtitle = out_glmer$chr_pos[1]) +
  theme(legend.position="none") + ylim(0,1)

```

![Raw data top 5 significantly changing CpG sites](../plots/model_out/plot_top_change_cpg.png){width="350" fig-align="left"}

## Note on LMM vs GLMM

I also executed a similar model to above but using a lmer where the response variable is the methylation % rather than nC, nT. Using the same filtering steps, I found a less CpG sites (203 vs 434 sites) with limited overlap between the two models (105 mutual sites).
